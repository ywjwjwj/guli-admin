/**
 * tdesign v0.38.1
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var isFunction = require('lodash/isFunction');
var tdesignIconsVue = require('tdesign-icons-vue');
var utils_mixins = require('../utils/mixins.js');
var configProvider_configReceiver = require('../config-provider/config-receiver.js');
var checkbox_index = require('../checkbox/index.js');
var loading_index = require('../loading/index.js');
var _common_js_tree_treeNode = require('../_common/js/tree/tree-node.js');
var tree_util = require('./util.js');
var tree_constants = require('./constants.js');
var utils_ripple = require('../utils/ripple.js');
require('vue');
require('lodash/mergeWith');
require('../config-provider/zh_CN_config.js');
require('../checkbox/group.js');
require('@babel/runtime/helpers/toConsumableArray');
require('../_chunks/dep-c2bd70fb.js');
require('@babel/runtime/helpers/typeof');
require('lodash/intersection');
require('../config.js');
require('../checkbox/checkbox.js');
require('../utils/render-tnode.js');
require('lodash/isObject');
require('../utils/classnames.js');
require('../checkbox/props.js');
require('../utils/helper.js');
require('@babel/runtime/helpers/objectWithoutProperties');
require('@babel/runtime/helpers/slicedToArray');
require('lodash/camelCase');
require('../utils/event.js');
require('../checkbox/checkbox-group-props.js');
require('../utils/map-props.js');
require('../utils/withInstall.js');
require('lodash/capitalize');
require('../loading/loading.js');
require('../loading/icon/gradient.js');
require('../_common/js/loading/circle-adapter.js');
require('../_common/js/utils/set-style.js');
require('../_common/js/utils/helper.js');
require('../utils/dom.js');
require('raf');
require('lodash/isString');
require('../utils/easing.js');
require('../utils/transfer-dom.js');
require('../loading/props.js');
require('../loading/plugin.js');
require('@babel/runtime/helpers/asyncToGenerator');
require('@babel/runtime/helpers/classCallCheck');
require('@babel/runtime/helpers/createClass');
require('@babel/runtime/regenerator');
require('lodash/uniqueId');
require('lodash/get');
require('../_common/js/tree/tree-node-model.js');
require('lodash/pick');
require('../_common/js/log/log.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var isFunction__default = /*#__PURE__*/_interopDefaultLegacy(isFunction);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var keepAnimationMixins = configProvider_configReceiver.getKeepAnimationMixins();
var TreeItemProps = {
  node: {
    type: _common_js_tree_treeNode.TreeNode
  },
  treeScope: {
    type: Object
  }
};
var TreeItem = utils_mixins["default"](configProvider_configReceiver["default"]("tree"), keepAnimationMixins).extend({
  name: tree_constants.TREE_NODE_NAME,
  props: TreeItemProps,
  directives: {
    ripple: utils_ripple["default"]
  },
  data: function data() {
    return {
      data: null,
      clicked: false
    };
  },
  methods: {
    getStyles: function getStyles() {
      var level = this.node.level;
      var styles = "--level: ".concat(level, ";");
      return styles;
    },
    getClassList: function getClassList() {
      var _list$push;

      var node = this.node;
      var list = [];
      list.push(tree_constants.CLASS_NAMES.treeNode);
      list.push((_list$push = {}, _defineProperty__default["default"](_list$push, tree_constants.CLASS_NAMES.treeNodeOpen, node.expanded), _defineProperty__default["default"](_list$push, tree_constants.CLASS_NAMES.actived, node.isActivable() ? node.actived : false), _defineProperty__default["default"](_list$push, tree_constants.CLASS_NAMES.disabled, node.isDisabled()), _list$push));

      if (node.visible) {
        list.push(tree_constants.CLASS_NAMES.treeNodeVisible);
      } else {
        list.push(tree_constants.CLASS_NAMES.treeNodeHidden);
      }

      return list;
    },
    renderLine: function renderLine(createElement) {
      var h = this.$createElement;
      var node = this.node,
          treeScope = this.treeScope;
      var line = treeScope.line,
          scopedSlots = treeScope.scopedSlots;
      var iconVisible = !!treeScope.icon;
      var lineNode = null;

      if (line === true) {
        if (scopedSlots !== null && scopedSlots !== void 0 && scopedSlots.line) {
          lineNode = scopedSlots.line({
            node: node === null || node === void 0 ? void 0 : node.getModel()
          });
        } else if (node.parent && node.tree) {
          var vmIsLeaf = node.vmIsLeaf,
              vmIsFirst = node.vmIsFirst,
              level = node.level;
          var lineClasses = [];
          lineClasses.push(tree_constants.CLASS_NAMES.line);

          if (vmIsLeaf || !iconVisible) {
            lineClasses.push(tree_constants.CLASS_NAMES.lineIsLeaf);
          }

          if (vmIsFirst && iconVisible) {
            lineClasses.push(tree_constants.CLASS_NAMES.lineIsFirst);
          }

          var shadowStyles = [];
          var parents = node.getParents();
          parents.pop();
          parents.forEach(function (pnode, index) {
            if (!pnode.vmIsLast) {
              shadowStyles.push("calc(-".concat(index + 1, " * var(--space)) 0 var(--color)"));
            }
          });
          var styles = {
            "--level": level ? String(level) : void 0,
            "box-shadow": shadowStyles.join(",")
          };
          lineNode = h("span", {
            "class": lineClasses,
            "style": styles
          });
        }
      } else {
        lineNode = tree_util.getTNode(line, {
          createElement: createElement,
          node: node
        });
      }

      return lineNode;
    },
    getFolderIcon: function getFolderIcon() {
      var h = this.$createElement;

      if (isFunction__default["default"](this.global.folderIcon)) {
        return this.global.folderIcon(this.$createElement);
      }

      return h(tdesignIconsVue.CaretRightSmallIcon);
    },
    renderIcon: function renderIcon(createElement) {
      var h = this.$createElement;
      var node = this.node,
          treeScope = this.treeScope;
      var icon = treeScope.icon,
          scopedSlots = treeScope.scopedSlots;
      var isDefaultIcon = false;
      var iconNode = null;

      if (icon === true) {
        if (scopedSlots !== null && scopedSlots !== void 0 && scopedSlots.icon) {
          iconNode = scopedSlots.icon({
            node: node === null || node === void 0 ? void 0 : node.getModel()
          });
        } else if (!node.vmIsLeaf) {
          isDefaultIcon = true;
          iconNode = this.getFolderIcon();

          if (node.loading && node.expanded) {
            iconNode = h(loading_index.Loading);
          }
        } else {
          iconNode = "";
        }
      } else {
        iconNode = tree_util.getTNode(icon, {
          createElement: createElement,
          node: node
        });
      }

      iconNode = h("span", {
        "class": [tree_constants.CLASS_NAMES.treeIcon, tree_constants.CLASS_NAMES.folderIcon, isDefaultIcon ? tree_constants.CLASS_NAMES.treeIconDefault : ""],
        "attrs": {
          "trigger": "expand",
          "ignore": "active"
        }
      }, [iconNode]);
      return iconNode;
    },
    renderLabel: function renderLabel(createElement) {
      var _this = this;

      var h = this.$createElement;
      var node = this.node,
          treeScope = this.treeScope;
      var label = treeScope.label,
          scopedSlots = treeScope.scopedSlots,
          disableCheck = treeScope.disableCheck;
      var checkProps = treeScope.checkProps || {};
      var labelNode = null;

      if (label === true) {
        if (scopedSlots !== null && scopedSlots !== void 0 && scopedSlots.label) {
          labelNode = scopedSlots.label({
            node: node === null || node === void 0 ? void 0 : node.getModel()
          });
        } else {
          labelNode = node.label || "";
        }
      } else {
        labelNode = tree_util.getTNode(label, {
          createElement: createElement,
          node: node
        });
      }

      var labelClasses = [tree_constants.CLASS_NAMES.treeLabel, tree_constants.CLASS_NAMES.treeLabelStrictly, _defineProperty__default["default"]({}, tree_constants.CLASS_NAMES.actived, node.isActivable() ? node.actived : false)];

      if (node.vmCheckable) {
        var checkboxDisabled = false;

        if (typeof disableCheck === "function") {
          checkboxDisabled = disableCheck(node);
        } else {
          checkboxDisabled = !!disableCheck;
        }

        if (node.isDisabled()) {
          checkboxDisabled = true;
        }

        var itemCheckProps = _objectSpread(_objectSpread({}, checkProps), {}, {
          disabled: checkboxDisabled
        });

        labelNode = h(checkbox_index.Checkbox, {
          "directives": [{
            name: "ripple",
            value: this.keepAnimation.ripple
          }],
          "class": labelClasses,
          "attrs": {
            "checked": node.checked,
            "indeterminate": node.indeterminate,
            "disabled": node.isDisabled(),
            "name": String(node.value),
            "ignore": "expand,active"
          },
          "on": {
            "change": function change() {
              return _this.handleChange();
            }
          },
          "props": _objectSpread({}, itemCheckProps)
        }, [labelNode]);
      } else {
        var inner = h("span", {
          "style": "position: relative"
        }, [labelNode]);
        labelNode = node.isActivable() ? h("span", {
          "key": "1",
          "directives": [{
            name: "ripple",
            value: this.keepAnimation.ripple
          }],
          "class": labelClasses
        }, [inner]) : h("span", {
          "key": "2",
          "class": labelClasses
        }, [inner]);
      }

      return labelNode;
    },
    renderOperations: function renderOperations(createElement) {
      var h = this.$createElement;
      var node = this.node,
          treeScope = this.treeScope;
      var operations = treeScope.operations,
          scopedSlots = treeScope.scopedSlots;
      var opNode = null;

      if (scopedSlots !== null && scopedSlots !== void 0 && scopedSlots.operations) {
        opNode = scopedSlots.operations({
          node: node === null || node === void 0 ? void 0 : node.getModel()
        });
      } else {
        opNode = tree_util.getTNode(operations, {
          createElement: createElement,
          node: node
        });
      }

      if (opNode) {
        opNode = h("span", {
          "class": tree_constants.CLASS_NAMES.treeOperations,
          "attrs": {
            "ignore": "active,expand"
          }
        }, [opNode]);
      }

      return opNode;
    },
    renderItem: function renderItem(createElement) {
      var itemNodes = [];
      var iconNode = this.renderIcon(createElement);
      var lineNode = this.renderLine(createElement);

      if (lineNode) {
        itemNodes.push(lineNode);
      }

      if (iconNode) {
        itemNodes.push(iconNode);
      }

      var labelNode = this.renderLabel(createElement);

      if (labelNode) {
        itemNodes.push(labelNode);
      }

      var opNode = this.renderOperations(createElement);

      if (opNode) {
        itemNodes.push(opNode);
      }

      return itemNodes;
    },
    handleClick: function handleClick(evt) {
      var _this2 = this;

      if (this.clicked) return;
      this.clicked = true;
      setTimeout(function () {
        _this2.clicked = false;
      });
      var node = this.node;
      var state = {
        mouseEvent: evt,
        event: evt,
        node: node,
        path: node.getPath()
      };
      this.$emit("click", state);
    },
    handleChange: function handleChange() {
      var node = this.node;
      var event = new Event("change");
      var state = {
        event: event,
        node: node
      };
      this.$emit("change", state);
    }
  },
  created: function created() {
    if (this.node) {
      this.data = this.node.data;
    }
  },
  destroyed: function destroyed() {
    this.data = null;
  },
  render: function render(createElement) {
    var _this3 = this;

    var h = arguments[0];
    var node = this.node;
    var tree = node.tree,
        level = node.level,
        value = node.value;

    if (!tree || !tree.nodeMap.get(value)) {
      this.$destroy();
    }

    var styles = this.getStyles();
    var classList = this.getClassList();
    return h("div", {
      "class": classList,
      "attrs": {
        "data-value": value,
        "data-level": level
      },
      "style": styles,
      "on": {
        "click": function click(evt) {
          return _this3.handleClick(evt);
        }
      }
    }, [this.renderItem(createElement)]);
  }
});

exports.TreeItemProps = TreeItemProps;
exports["default"] = TreeItem;
//# sourceMappingURL=tree-item.js.map
