/**
 * tdesign v0.38.1
 * (c) 2022 tdesign
 * @license MIT
 */

import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import get from 'lodash/get';
import { isRowSelectedDisabled } from '../util/common.js';
import 'lodash/isFunction';
import 'lodash/isString';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var TableTreeStore = /*#__PURE__*/function () {
  function TableTreeStore() {
    _classCallCheck(this, TableTreeStore);

    _defineProperty(this, "treeDataMap", /* @__PURE__ */new Map());

    this.treeDataMap = /* @__PURE__ */new Map();
  }

  _createClass(TableTreeStore, [{
    key: "initialTreeStore",
    value: function initialTreeStore(dataSource, columns, keys) {
      var _this$treeDataMap;

      (_this$treeDataMap = this.treeDataMap) === null || _this$treeDataMap === void 0 ? void 0 : _this$treeDataMap.clear();
      initialTreeDataMap(this.treeDataMap, dataSource, columns[0], keys);
    }
  }, {
    key: "toggleExpandData",
    value: function toggleExpandData(p, dataSouce, keys) {
      var rowValue = get(p.row, keys.rowKey);
      var r = this.treeDataMap.get(rowValue) || {
        row: p.row,
        rowIndex: p.rowIndex,
        expanded: false
      };
      r.rowIndex = p.rowIndex;
      r.expanded = !r.expanded;
      this.treeDataMap.set(rowValue, r);
      this.updateExpandRow(r, dataSouce, keys);
    }
  }, {
    key: "updateExpandRow",
    value: function updateExpandRow(changeRow, dataSource, keys) {
      var row = changeRow.row,
          rowIndex = changeRow.rowIndex,
          expanded = changeRow.expanded;
      var treeDataMap = this.treeDataMap;
      var childrenNodes = get(row, keys.childrenKey);
      if (!row || !childrenNodes) return;

      if (expanded) {
        updateChildrenRowState(treeDataMap, changeRow, expanded, keys);
        updateRowExpandLength(treeDataMap, row, childrenNodes.length, "expand", keys);
        dataSource.splice.apply(dataSource, [rowIndex + 1, 0].concat(childrenNodes));
      } else {
        updateChildrenRowState(treeDataMap, changeRow, expanded, keys);
        var len = changeRow.expandChildrenLength || childrenNodes.length;
        updateRowExpandLength(treeDataMap, row, -1 * len, "fold", keys);
        dataSource.splice(rowIndex + 1, len);
      }

      updateRowIndex(treeDataMap, dataSource, {
        rowKey: keys.rowKey,
        minRowIndex: rowIndex + 1
      });
    }
  }, {
    key: "getData",
    value: function getData(key) {
      return this.treeDataMap.get(key);
    }
  }, {
    key: "updateData",
    value: function updateData(key, newRowData, dataSource, keys) {
      var newKey = get(newRowData, keys.rowKey);
      var rowState = this.treeDataMap.get(key);

      if (!rowState || rowState.rowIndex === -1) {
        updateRowData(dataSource, key, newRowData, {
          rowKey: keys.rowKey,
          childrenKey: keys.childrenKey
        });
        return;
      }

      var currentRowIndex = rowState.rowIndex;
      rowState.row = newRowData;
      this.treeDataMap.set(key, rowState);

      if (rowState.parent) {
        var siblings = get(rowState.parent.row, keys.childrenKey);
        var index = siblings.findIndex(function (item) {
          return get(item, keys.rowKey) === key;
        });
        siblings[index] = newRowData;
      }

      if (key !== newKey) {
        this.treeDataMap.set(newKey, rowState);
        this.treeDataMap["delete"](key);
      } else {
        this.treeDataMap.set(key, rowState);
      }

      return currentRowIndex;
    }
  }, {
    key: "remove",
    value: function remove(key, dataSource, keys) {
      var r = this.treeDataMap.get(key);

      if (r && r.rowIndex >= 0) {
        var removeNumber = (r.expandChildrenLength || 0) + 1;
        dataSource.splice(r.rowIndex, removeNumber);

        if (r.parent) {
          var siblings = get(r.parent.row, keys.childrenKey);
          var index = siblings.findIndex(function (item) {
            return get(item, keys.rowKey) === key;
          });
          siblings.splice(index, 1);
          updateRowExpandLength(this.treeDataMap, r.parent.row, -1 * removeNumber, "delete", {
            rowKey: keys.rowKey,
            childrenKey: keys.childrenKey
          });
        }

        this.treeDataMap["delete"](key);
        updateRowIndex(this.treeDataMap, dataSource, {
          minRowIndex: r.rowIndex,
          rowKey: keys.rowKey
        });
      } else {
        console.warn("TDesign Table Warn: Do not remove this node, which is not appreared.");
      }

      return dataSource;
    }
  }, {
    key: "appendTo",
    value: function appendTo(key, newData, dataSource, keys) {
      var state = this.treeDataMap.get(key);

      if (!state) {
        console.warn("TDesign Table Warn: ".concat(key, " is not exist."));
        return;
      }

      var newRowValue = get(newData, keys.rowKey);

      if (this.treeDataMap.get(newRowValue)) {
        console.warn("TDesign Table Warn: Duplicated Key. ".concat(newRowValue, " is already exists."));
        return;
      }

      var children = get(state.row, keys.childrenKey);
      var isShowNewNode = state.expanded || !(children !== null && children !== void 0 && children.length);
      var newState = {
        row: newData,
        level: state.level + 1,
        parent: state,
        path: _toConsumableArray(state.path),
        expanded: false,
        expandChildrenLength: 0,
        rowIndex: isShowNewNode ? state.rowIndex + (state.expandChildrenLength || 0) + 1 : -1
      };
      newState.path = newState.path.concat(newState);

      if (children !== null && children !== void 0 && children.length) {
        state.row[keys.childrenKey].push(newData);
      } else {
        state.row[keys.childrenKey] = [newData];
        state.expanded = true;
      }

      this.treeDataMap.set(newRowValue, newState);

      if (isShowNewNode) {
        dataSource.splice(newState.rowIndex, 0, newData);
        updateRowExpandLength(this.treeDataMap, state.row, 1, "insert", {
          rowKey: keys.rowKey,
          childrenKey: keys.childrenKey
        });
        updateRowIndex(this.treeDataMap, dataSource, {
          minRowIndex: newState.rowIndex,
          rowKey: keys.rowKey
        });
      }

      return dataSource;
    }
  }]);

  return TableTreeStore;
}();
function initialTreeDataMap(treeDataMap, dataSource, column, keys) {
  for (var i = 0, len = dataSource.length; i < len; i++) {
    var item = dataSource[i];
    var rowValue = get(item, keys.rowKey);
    var state = {
      row: item,
      rowIndex: i,
      expanded: false,
      level: 0,
      expandChildrenLength: 0,
      disabled: isRowSelectedDisabled(column, item, i)
    };
    state.path = [state];
    treeDataMap.set(rowValue, state);
    var children = get(item, keys.childrenKey);

    if (column.colKey === "row-select" && children !== null && children !== void 0 && children.length) {
      initialTreeDataMap(treeDataMap, children, column, keys);
    }
  }
}
function updateRowExpandLength(treeDataMap, row, distance, type, keys) {
  var tmp = row;

  while (tmp) {
    var _state$parent;

    var state = treeDataMap.get(get(tmp, keys.rowKey));
    var expandLen = (state.expandChildrenLength || 0) + distance;
    state.expandChildrenLength = Math.max(0, expandLen);
    tmp = state === null || state === void 0 ? void 0 : (_state$parent = state.parent) === null || _state$parent === void 0 ? void 0 : _state$parent.row;
  }

  if (type === "fold") {
    clearRowExpandLength(treeDataMap, row, keys);
  }
}
function clearRowExpandLength(treeDataMap, row, keys) {
  var children = get(row, keys.childrenKey);

  if (children !== null && children !== void 0 && children.length) {
    children.forEach(function (item) {
      var state = treeDataMap.get(get(item, keys.rowKey));
      if (!state) return;
      state.expandChildrenLength = 0;
      clearRowExpandLength(treeDataMap, state.row, keys);
    });
  }
}
function updateChildrenRowState(treeDataMap, rowState, expanded, keys) {
  var row = rowState.row,
      _rowState$level = rowState.level,
      level = _rowState$level === void 0 ? 0 : _rowState$level,
      rowIndex = rowState.rowIndex;
  var childrenNodes = get(row, keys.childrenKey);
  childrenNodes.forEach(function (item, kidRowIndex) {
    var rowValue = get(item, keys.rowKey);
    var index = expanded ? rowIndex + 1 + kidRowIndex : -1;
    var curState = treeDataMap.get(rowValue);

    var newState = _objectSpread(_objectSpread({}, curState), {}, {
      row: item,
      rowIndex: index,
      expanded: false,
      parent: rowState,
      level: level + 1,
      path: []
    });

    newState.path = newState.path.concat(newState);
    treeDataMap.set(rowValue, newState);

    if (!expanded) {
      var children = get(item, keys.childrenKey);

      if (children !== null && children !== void 0 && children.length) {
        updateChildrenRowState(treeDataMap, _objectSpread(_objectSpread({}, newState), {}, {
          rowIndex: -1,
          expanded: false
        }), expanded, keys);
      }
    }
  });
}
function updateRowData(data, key, newData, keys) {
  for (var i = 0, len = data.length; i < len; i++) {
    var item = data[i];

    if (get(item, keys.rowKey) === key) {
      data[i] = newData;
      return;
    }

    var children = get(item, keys.childrenKey) || [];

    if (children !== null && children !== void 0 && children.length) {
      updateRowData(children, key, newData, keys);
    }
  }
}
function updateRowIndex(treeDataMap, dataSource, extra) {
  var start = extra.minRowIndex || 0;
  var end = extra.maxRowIndex || dataSource.length;

  for (var rowIndex = start; rowIndex < end; rowIndex++) {
    var item = dataSource[rowIndex];
    var state = treeDataMap.get(get(item, extra.rowKey));
    state.rowIndex = rowIndex;
  }
}

export { clearRowExpandLength, TableTreeStore as default, initialTreeDataMap, updateChildrenRowState, updateRowData, updateRowExpandLength, updateRowIndex };
//# sourceMappingURL=tree-store.js.map
