/**
 * tdesign v0.38.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { h as helper } from '../../_chunks/dep-99305448.js';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import Vue from 'vue';
import { prefix } from '../../config.js';
import { Popup } from '../../popup/index.js';
import { isNodeOverflow } from '../../utils/dom.js';
import { getRecord } from '../util/common.js';
import { emitEvent } from '../../utils/event.js';
import '../../popup/popup.js';
import '@babel/runtime/helpers/typeof';
import '@popperjs/core';
import '../../utils/classnames.js';
import '../../utils/render-tnode.js';
import 'lodash/isObject';
import '../../utils/helper.js';
import '@babel/runtime/helpers/objectWithoutProperties';
import '@babel/runtime/helpers/slicedToArray';
import 'lodash/camelCase';
import '../../_common/js/utils/set-style.js';
import '../../popup/props.js';
import '../../popup/container.js';
import 'raf';
import 'lodash/isString';
import '../../utils/easing.js';
import '../../utils/map-props.js';
import '../../utils/withInstall.js';
import 'lodash/capitalize';
import './style/css.js';
import '../../popup/type.js';
import 'lodash/isFunction';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var ELLIPSIS_CLASS_NAME = "".concat(prefix, "-text-ellipsis");
var overlayStyle = {
  width: "100%",
  maxWidth: "400px",
  wordBreak: "break-all"
};
var TableCell = Vue.extend({
  name: "".concat(prefix, "-table-cell"),
  props: {
    cellData: {
      type: Object,
      "default": function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      offsetLeft: 0,
      isBoundary: false,
      isCutOff: false
    };
  },
  methods: {
    init: function init() {
      var _this$cellData,
          _this = this;

      var _this$cellData$col = (_this$cellData = this.cellData) === null || _this$cellData === void 0 ? void 0 : _this$cellData.col,
          fixed = _this$cellData$col.fixed;

      var children = this.$parent.$children;

      if (fixed) {
        var offsetLeft = 0;
        var fixedColumns = children.filter(function (el) {
          var _el$cellData, _el$cellData$col;

          return (el === null || el === void 0 ? void 0 : (_el$cellData = el.cellData) === null || _el$cellData === void 0 ? void 0 : (_el$cellData$col = _el$cellData.col) === null || _el$cellData$col === void 0 ? void 0 : _el$cellData$col.fixed) === fixed;
        });
        var indexInFixedColumns = fixedColumns.findIndex(function (el) {
          return el === _this;
        });
        fixedColumns.forEach(function (el, cur) {
          if (fixed === "right" && cur > indexInFixedColumns || fixed === "left" && cur < indexInFixedColumns) {
            var _el$cellData2;

            var width = parseInt((_el$cellData2 = el.cellData) === null || _el$cellData2 === void 0 ? void 0 : _el$cellData2.col["with"], 10);
            var clientWidth = el.$el.clientWidth;
            offsetLeft += width > 0 ? width : clientWidth;
          }
        });
        this.isBoundary = fixed === "left" ? indexInFixedColumns === fixedColumns.length - 1 : indexInFixedColumns === 0;
        this.offsetLeft = offsetLeft;
      }

      this.isCutOff = isNodeOverflow(this.$el);
    }
  },
  render: function render(h) {
    var _col$attrs,
        _this2 = this;

    var cellData = this.cellData;
    var col = cellData.col,
        colIndex = cellData.colIndex,
        row = cellData.row,
        rowIndex = cellData.rowIndex,
        customData = cellData.customData,
        customRender = cellData.customRender,
        withoutBorder = cellData.withoutBorder,
        withBorder = cellData.withBorder;
    var colKey = col.colKey,
        attrs = col.attrs,
        align = col.align,
        ellipsis = col.ellipsis,
        width = col.width,
        className = col.className,
        title = col.title,
        fixed = col.fixed;

    var style = _objectSpread({}, (_col$attrs = col.attrs) === null || _col$attrs === void 0 ? void 0 : _col$attrs.style);

    var fixedClass = [];
    var attrClass = (attrs === null || attrs === void 0 ? void 0 : attrs["class"]) || [];

    if (fixed) {
      style.position = "sticky";
      style[fixed] = "".concat(this.offsetLeft, "px");
      fixedClass.push("".concat(prefix, "-table__cell--fixed-").concat(fixed));

      if (this.isBoundary) {
        fixedClass.push("".concat(prefix, "-table__cell--fixed-").concat(fixed, "-").concat(fixed === "left" ? "last" : "first"));
      }
    }

    if (align) {
      attrClass.push("".concat(prefix, "-align-").concat(align));
    }

    if (width && !fixed) {
      style.overflow = "hidden";
    }

    if (withoutBorder === true) {
      style.borderLeftWidth = "0px";
    }

    if (withBorder === true) {
      style.borderLeftWidth = "1px";
    }

    if (ellipsis === true || typeof ellipsis === "function") {
      attrClass.push("".concat(prefix, "-text-ellipsis"));
    }

    if (className) {
      if (typeof className === "function") {
        attrClass.push(className({
          type: cellData.type,
          col: col,
          colIndex: colIndex,
          row: row,
          rowIndex: rowIndex
        }));
      } else {
        attrClass.push(className);
      }
    }

    if (["single", "multiple"].indexOf(col.type) > -1) {
      attrClass.push("".concat(prefix, "-table__cell--selectable"));
    }

    var record = getRecord(row);
    var cellContent;

    if (typeof customRender === "function") {
      var type = customData.type,
          func = customData.func;
      var baseData = {
        col: col,
        colIndex: colIndex,
        row: row,
        rowIndex: rowIndex,
        record: record
      };

      if (func === "title") {
        cellContent = customRender(h, {
          col: col,
          colIndex: colIndex,
          type: type
        });
      } else if (func === "cell") {
        cellContent = customRender(h, baseData);
      } else if (func === "render") {
        cellContent = customRender(h, _objectSpread({
          type: type
        }, baseData));
      }
    } else {
      cellContent = this.$createElement(title || "");
    }

    var tdAttrs = {
      attrs: _objectSpread(_objectSpread({}, attrs), {}, {
        "class": [].concat(fixedClass, _toConsumableArray(attrClass)).filter(function (notEmpty) {
          return notEmpty;
        }).join(" "),
        key: colKey
      }),
      style: style,
      on: {
        click: function click(e) {
          emitEvent(_this2, "cell-click", {
            col: col,
            colIndex: colIndex,
            row: row,
            rowIndex: rowIndex,
            e: e
          });
        }
      }
    };
    var newCellContent = cellContent;

    if (ellipsis && this.isCutOff) {
      var popupCellContent = cellContent;

      if (typeof ellipsis === "function") {
        popupCellContent = ellipsis(h, {
          row: row,
          col: col,
          rowIndex: rowIndex,
          colIndex: colIndex
        });
      }

      this.$nextTick(function () {
        var _cellContent;

        if ((_cellContent = cellContent) !== null && _cellContent !== void 0 && _cellContent.elm) {
          var _elm$classList, _elm$classList$remove, _elm$classList2, _elm$classList2$add;

          var elm = cellContent.elm;
          (_elm$classList = elm.classList) === null || _elm$classList === void 0 ? void 0 : (_elm$classList$remove = _elm$classList.remove) === null || _elm$classList$remove === void 0 ? void 0 : _elm$classList$remove.call(_elm$classList, ELLIPSIS_CLASS_NAME);
          (_elm$classList2 = elm.classList) === null || _elm$classList2 === void 0 ? void 0 : (_elm$classList2$add = _elm$classList2.add) === null || _elm$classList2$add === void 0 ? void 0 : _elm$classList2$add.call(_elm$classList2, ELLIPSIS_CLASS_NAME);
        }
      });
      newCellContent = h(Popup, {
        "style": "display: inline;",
        "attrs": {
          "overlayStyle": overlayStyle,
          "placement": "bottom-left",
          "showArrow": false,
          "content": function content() {
            return popupCellContent;
          }
        }
      }, [cellContent]);
    }

    return h("td", helper([{}, tdAttrs]), [newCellContent]);
  },
  mounted: function mounted() {
    this.init();
  },
  updated: function updated() {
    this.init();
  }
});

export { ELLIPSIS_CLASS_NAME, TableCell as default };
//# sourceMappingURL=table-cell.js.map
