/**
 * tdesign v0.38.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { h as helper } from '../../../_chunks/dep-99305448.js';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import Vue from 'vue';
import isFunction from 'lodash/isFunction';
import SorterButton from '../sorter-button.js';
import { prefix } from '../../../config.js';
import primaryTableProps from '../../primary-table-props.js';
import baseTableProps from '../../base-table-props.js';
import { emitEvent } from '../../../utils/event.js';
import { getTitle } from '../../util/common.js';
import 'tdesign-icons-vue';
import '../../../utils/mixins.js';
import '../../../config-provider/config-receiver.js';
import 'lodash/mergeWith';
import '../../../config-provider/zh_CN_config.js';
import '../../../config-provider/type.js';
import '../../../tooltip/index.js';
import '../../../tooltip/tooltip.js';
import '../../../tooltip/props.js';
import '../../../popup/props.js';
import '../../../popup/popup.js';
import '@babel/runtime/helpers/typeof';
import '@popperjs/core';
import '../../../utils/classnames.js';
import '../../../utils/dom.js';
import 'raf';
import 'lodash/isString';
import '../../../utils/easing.js';
import '../../../utils/render-tnode.js';
import 'lodash/isObject';
import '../../../utils/helper.js';
import '@babel/runtime/helpers/objectWithoutProperties';
import '@babel/runtime/helpers/slicedToArray';
import 'lodash/camelCase';
import '../../../_common/js/utils/set-style.js';
import '../../../popup/container.js';
import '../../../utils/map-props.js';
import '../../../utils/withInstall.js';
import 'lodash/capitalize';
import './style/index.js';
import '../../../tooltip/type.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var sort = Vue.extend({
  name: "".concat(prefix, "-primary-table-sort"),
  props: {
    data: baseTableProps.data,
    columns: primaryTableProps.columns,
    sort: primaryTableProps.sort,
    multipleSort: primaryTableProps.multipleSort
  },
  data: function data() {
    return {
      sorterFuncMap: {}
    };
  },
  computed: {
    sortArray: function sortArray() {
      var sort = this.sort;
      if (!sort) return [];
      return Array.isArray(sort) ? sort : [sort];
    },
    sortMap: function sortMap() {
      var sortMap = {};
      this.sortArray.forEach(function (info, index) {
        var sortBy = info.sortBy;
        sortMap[sortBy] = _objectSpread({
          index: index
        }, info);
      });
      return sortMap;
    },
    localDataSort: function localDataSort() {
      return !!Object.keys(this.sorterFuncMap).length;
    }
  },
  methods: {
    handleDataSort: function handleDataSort() {
      var _this = this;

      var data = this.data,
          sort = this.sort;
      if (!sort || !this.localDataSort) return;
      var formatedSort = sort instanceof Array ? sort : [sort];
      var newData = data.slice().sort(function (a, b) {
        var sortResult = 0;

        for (var i = 0, len = formatedSort.length; i < len; i++) {
          var item = formatedSort[i];
          var sortFunc = _this.sorterFuncMap[item.sortBy];

          if (sortResult === 0 && sortFunc) {
            sortResult = item.descending ? sortFunc(b, a) : sortFunc(a, b);

            if (sortResult !== 0) {
              sortResult = sortResult > 0 ? 1 : -1;
            }
          } else {
            break;
          }
        }

        return sortResult;
      });
      if (JSON.stringify(newData) === JSON.stringify(this.data)) return;
      emitEvent(this, "data-change", newData);
      return newData;
    },
    needSort: function needSort(column) {
      var sorter = column.sorter,
          sortType = column.sortType;
      return sorter && (!sortType || Array.isArray(sortType) && sortType.length > 0 || typeof sortType === "string");
    },
    getNextSortOrder: function getNextSortOrder(currentSortOrder, sortType) {
      var sorterTypes = !sortType || sortType === "all" ? ["desc", "asc"] : [sortType];
      var idx = (sorterTypes.indexOf(currentSortOrder) + 1) % (sorterTypes.length + 1);
      return sorterTypes[idx];
    },
    handleSortHeaderClick: function handleSortHeaderClick(col) {
      var newData = this.handleDataSort();
      var sortInfo;

      if (this.multipleSort) {
        sortInfo = this.getMultipleNextSort(col);
      } else {
        sortInfo = this.getSingleNextSort(col);
      }

      emitEvent(this, "sort-change", sortInfo, {
        currentDataSource: newData || this.data,
        col: col
      });
      emitEvent(this, "change", {
        sorter: sortInfo
      }, {
        trigger: "sorter",
        currentData: newData || this.data
      });
    },
    getSortColumn: function getSortColumn(colKey) {
      return this.columns.find(function (column) {
        return column.colKey === colKey;
      });
    },
    getSortOrder: function getSortOrder(descending) {
      if (descending === void 0) return;
      return descending ? "desc" : "asc";
    },
    getNextDescending: function getNextDescending(current, col) {
      var _ref = current || {},
          descending = _ref.descending;

      var _col$sortType = col.sortType,
          sortType = _col$sortType === void 0 ? "all" : _col$sortType;
      if (descending === true && ["asc", "all"].includes(sortType)) return false;
      if (descending === void 0 && ["desc", "all"].includes(sortType)) return true;
    },
    getSingleNextSort: function getSingleNextSort(col) {
      var colKey = col.colKey;
      var current = this.sortMap[colKey];
      var next = this.getNextDescending(current, col);
      if (next === void 0) return;
      return {
        sortBy: colKey,
        descending: next
      };
    },
    getMultipleNextSort: function getMultipleNextSort(col) {
      if (!(this.sort instanceof Array)) return;
      var colKey = col.colKey;

      var result = _toConsumableArray(this.sort);

      for (var i = 0, len = this.sort.length; i < len; i++) {
        if (this.sort[i].sortBy === colKey) {
          var next = this.getSingleNextSort(col);
          next ? result[i] = next : result.splice(i, 1);
          return result;
        }
      }

      result.push({
        sortBy: colKey,
        descending: true
      });
      return result;
    },
    getSorterColumns: function getSorterColumns(columns) {
      var _this2 = this;

      var h = this.$createElement;
      var r = columns.map(function (item, index) {
        var _column$children;

        var column = _objectSpread({}, item);

        if ((_column$children = column.children) !== null && _column$children !== void 0 && _column$children.length) {
          column.children = _toConsumableArray(_this2.getSorterColumns(column.children));
        } else {
          if (isFunction(column.sorter)) {
            _this2.sorterFuncMap[column.colKey] = column.sorter;
          }

          var needSort = _this2.needSort(column);

          if (needSort) {
            var _this2$sortMap$colKey;

            var _column$sortType = column.sortType,
                sortType = _column$sortType === void 0 ? "all" : _column$sortType,
                colKey = column.colKey;

            var nextSort = _this2.getSingleNextSort(column);

            var sorterButtonsProps = {
              on: {
                click: function click() {
                  return _this2.handleSortHeaderClick(column);
                }
              },
              props: {
                sortType: sortType,
                sortOrder: _this2.getSortOrder((_this2$sortMap$colKey = _this2.sortMap[colKey]) === null || _this2$sortMap$colKey === void 0 ? void 0 : _this2$sortMap$colKey.descending),
                nextSortOrder: _this2.getSortOrder(nextSort === null || nextSort === void 0 ? void 0 : nextSort.descending)
              }
            };
            var title = getTitle(_this2, column, index);

            column.title = function () {
              return h("div", {
                "class": "".concat(prefix, "-table__cell--sortable")
              }, [h("div", {
                "class": "".concat(prefix, "-table__cell--title")
              }, [h("div", [title]), h(SorterButton, helper([{}, sorterButtonsProps]))])]);
            };
          }
        }

        return column;
      });
      this.handleDataSort();
      return r;
    }
  }
});

export { sort as default };
//# sourceMappingURL=sort.js.map
